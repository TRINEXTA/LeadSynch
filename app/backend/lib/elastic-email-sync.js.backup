import { queryAll, queryOne, execute } from './db.js';
import axios from 'axios';

const ELASTIC_API_KEY = process.env.ELASTIC_EMAIL_API_KEY;
const SYNC_INTERVAL = 5 * 60 * 1000; // 5 minutes

export class ElasticEmailSyncWorker {
  
  async syncAllActiveCampaigns() {
    try {
      console.log('🔄 [WORKER] Synchronisation des campagnes actives...');
      
      const campaigns = await queryAll(`
        SELECT c.id, c.name, c.tenant_id, c.created_at, c.sent_count, c.status, c.type, c.tracking_end_date
        FROM campaigns c
        WHERE c.status IN ('active', 'tracking', 'completed')
        AND c.type = 'email'
        AND c.created_at > NOW() - INTERVAL '30 days'
        ORDER BY c.created_at DESC
      `);
      
      console.log(`📊 [WORKER] ${campaigns.length} campagnes à synchroniser`);
      
      for (const campaign of campaigns) {
        // Vérifier si la période de tracking est terminée
        if (campaign.status === 'tracking' && campaign.tracking_end_date) {
          const now = new Date();
          const trackingEnd = new Date(campaign.tracking_end_date);
          
          if (now > trackingEnd) {
            await execute(`
              UPDATE campaigns 
              SET status = 'completed', updated_at = NOW()
              WHERE id = $1
            `, [campaign.id]);
            console.log(`🏁 [WORKER] Campagne "${campaign.name}" tracking terminé → completed`);
            continue; // Ne pas syncer, elle est finie
          }
        }
        
        await this.syncCampaignStats(campaign);
        await new Promise(resolve => setTimeout(resolve, 3000)); // 3 secondes entre chaque
      }
      
      await this.checkCompletedCampaigns();
      
      console.log('✅ [WORKER] Synchronisation terminée\n');
      
    } catch (error) {
      console.error('❌ [WORKER] Erreur sync:', error);
    }
  }
  
  async checkCompletedCampaigns() {
    try {
      // Vérifier dans email_queue au lieu de campaign_leads
      // Ne pas marquer comme completed les campagnes en tracking
      const campaigns = await queryAll(`
        SELECT c.id, c.name
        FROM campaigns c
        WHERE c.status = 'active'
        AND c.type = 'email'
        AND NOT EXISTS (
          SELECT 1 FROM email_queue eq 
          WHERE eq.campaign_id = c.id AND eq.status = 'pending'
        )
      `);
      
      for (const campaign of campaigns) {
        // Passer en mode tracking au lieu de completed
        await execute(`
          UPDATE campaigns 
          SET status = 'tracking',
              tracking_end_date = NOW() + INTERVAL '15 days',
              updated_at = NOW()
          WHERE id = $1
        `, [campaign.id]);
        console.log(`📊 [WORKER] Campagne "${campaign.name}" → mode tracking (15 jours)`);
      }
      
    } catch (error) {
      console.error('❌ [WORKER] Erreur check completed:', error);
    }
  }
  
  async syncCampaignStats(campaign) {
    try {
      console.log(`🔍 [WORKER] Sync "${campaign.name}"...`);
      
      // Récupérer les stats depuis email_queue (pas campaign_leads)
      const emailQueueStats = await queryOne(`
        SELECT 
          COUNT(*) as total,
          COUNT(CASE WHEN status = 'sent' THEN 1 END) as sent,
          COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending,
          COUNT(CASE WHEN status = 'failed' THEN 1 END) as failed
        FROM email_queue
        WHERE campaign_id = $1
      `, [campaign.id]);
      
      // Récupérer les stats de tracking
      const trackingStats = await queryOne(`
        SELECT 
          COUNT(CASE WHEN event_type = 'delivered' THEN 1 END) as delivered,
          COUNT(CASE WHEN event_type = 'open' THEN 1 END) as opened,
          COUNT(CASE WHEN event_type = 'click' THEN 1 END) as clicked,
          COUNT(CASE WHEN event_type = 'bounce' THEN 1 END) as bounced
        FROM email_tracking
        WHERE campaign_id = $1
      `, [campaign.id]);
      
      // Mettre à jour SEULEMENT les stats d'envoi (pas total_leads)
      await execute(`
        UPDATE campaigns 
        SET 
          sent_count = $1,
          delivered_count = $2,
          opened_count = $3,
          clicked_count = $4,
          updated_at = NOW()
        WHERE id = $5
      `, [
        emailQueueStats.sent || 0,
        trackingStats.delivered || emailQueueStats.sent || 0,
        trackingStats.opened || 0,
        trackingStats.clicked || 0,
        campaign.id
      ]);
      
      console.log(`📊 [WORKER] "${campaign.name}": ${emailQueueStats.total} total, ${emailQueueStats.sent} envoyés, ${trackingStats.opened} ouverts, ${trackingStats.clicked} cliqués`);
      
    } catch (error) {
      console.error(`❌ [WORKER] Erreur sync "${campaign.name}":`, error.message);
    }
  }
  
  start() {
    console.log('🚀 [WORKER] Démarrage du worker de synchronisation');
    console.log(`⏱️ [WORKER] Intervalle: ${SYNC_INTERVAL / 60000} minutes\n`);
    
    // Première synchro immédiate
    this.syncAllActiveCampaigns();
    
    // Puis toutes les 5 minutes
    setInterval(() => {
      this.syncAllActiveCampaigns();
    }, SYNC_INTERVAL);
  }
}

export const syncWorker = new ElasticEmailSyncWorker();